	
	在css选择器的优先级

	如果已经把.polaris下面span内的字体设置成红色：

	.polaris span {color:red;} 
	这时，如果要改变.beijixing的颜色为蓝色，用下面的命令是不能实现的：

	.beijixing {color:blue;} 
	出现这种情况就是因为后一个命令的优先级不够，两条相互冲突的样式设置，浏览器只会执行优先级较高的那个。

	一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。
	通常我们用1表示标签名选择器的优先级，用10表示类选择器的优先级，用100标示ID选择器的优先级。
	比如上例当中 .polaris span {color:red;}的选择器优先级是 10 + 1 也就是11；而 .polaris 的优先级是10；浏览器自然会显示红色的字。
	理解了这个道理之后下面的优先级计算自是易如反掌：

	div.test1 .span var 优先级 1+10 +10 +1  
	span#xxx .songs li 优先级1+100 + 10 + 1  
	#xxx li 优先级 100 +1 

	本文来源：http://developer.51cto.com/art/201009/226852.htm

	//优先级依次增强
	通用选择器（*）
	元素(类型)选择器
	类选择器
	属性选择器
	伪类
	ID 选择器
	内联样式

	https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity


	-------------------------------------------------------------------------------
	css媒体查询

	媒体查询 包含了一个媒体类型和至少一个使用如宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。
	//<!-- link元素中的CSS媒体查询 -->
	<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />

	//<!-- 样式表中的CSS媒体查询 -->
	<style>
	@media (max-width: 600px) { //宽度小于600px的设备
	  .facet_sidebar {
		display: none;
	  }
	}
	@media screen and (min-width: 500px) and (max-width: 800px) { //宽度在500到800之间的设备
	
	}
	</style>

	--------------------------------------------------------------------------------------

	box-sizing:border-box;padding:10px;width:100%;

	如果没有用css设置height，而是用js设置，那么div的高度为height+padding，也就是说此时border-box对height方向的padding已不再有约束力

	js是无法获取到【:before】之类的为元素的
	jquery 提供的伪类选择器都是针对html元素的，而 css 中 :after 和 :before 这些是伪元素，jquery 中并不能获取这些伪元素。
	
    -----------------------------------------------------------------------------------
	js获取高度:

	obj.style.width(height);//除非在css中设置了width，才能获取到

	obj.offsetWidth(offsetHeight); //offsetWidth得到的是width值+padding值+border值

	obj.clientWidth(clientHeight); //offsetWidth得到的是width值+padding值

	getComputedStyle 与 currentStyle; //getComputedStyle 与 currentStyle是处理兼容性的两个方法，获取到的值都是图片在屏幕上显示的仅仅图片的高宽值，不会获取到img标签的padding及border值；但其中getComputedStyle适用于Firefox/IE9/Safari/Chrome/Opera浏览器，currentStyle适用于IE6/7/8。但是如果img标签即使没有设置style属性也没有引入样式表，那么只有getComputedStyle能获取到值，即为图片本身高宽值，currentStyle则返回auto。

	obj.naturalWidth(naturalHeight); //这是HTML5里新添加的一个获取元素高宽的方法，但只适用于Firefox/IE9/Safari/Chrome/Opera浏览器。

	注意: 如果一个图片没有加载完毕，是无法获取到他的高度的！

	--------------------------------------------------------------------------------------------
	placeholder样式设定
	[placeholder] { font-family: 'Microsoft yahei'; } //字体
	::-moz-placeholder {
		color: mediumvioletred; //颜色值
		text-indent: 5px; /* 没有用 */
		opacity: 1!important; //透明度？
	}
	:-ms-input-placeholder {
		color: mediumvioletred;
		text-indent: 5px;
	}
	::-webkit-input-placeholder {
		color: mediumvioletred;
		text-indent: 5px; //顾名思义，placeholder的缩进
	}

	-----------------------------------------------------------------------------------------------

	css文本溢出后，显示省略号
	{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;height:100px;width:100px;} /* 高度是必需的 */

	overflow:hidden;;/* 内容超出宽度时隐藏超出部分的内容 */
	text-overflow:ellipsis;;/* 当对象内文本溢出时显示省略标记(...) ；需与overflow:hidden;一起使用。*/
	white-space:nowrap;/* 不换行 */

	上面的只适用于但行文本
	多行文本用下方法

	overflow:hidden; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient: vertical; text-overflow: ellipsis;
	-webkit-line-clamp:2;数字表示行数

	-----------------------------------------------------------------------------------------------

	删除对象属性
	bitch = new Object();
	bitch.name = 'nihao';

	现在我想删除bitch的name属性，就用delete方法
	delete bitch.name
	console.log(typeof(bitch.name)) //输出undefined

	直接用delelte删除不了变量
    删除不了原型链中的变量

	创建一个对象 可以用【new Object()】
	也可以用函数构造一个 
	
		function bitch(){
			console.log(arguments.length)//输出函数形参个数
			this.name = "nihao";
			this.log = function (str){
				console.log(str);
				//console.log(arguments.length)
			}
		}
		var bitch1 = new bitch(1,2,3); //arguments.length = 3
		var allProperty = Object.getOwnPropertyNames(bitch1);//获取对象所有属性【可枚举，不可枚举】，以数组形式返回 不可枚举指的是内建对象的属性
															//我们能创建的对象，都是内建对象的一个引用（的引用（的引用。。。）），都是可以枚举的……
		var keys = Object.keys(bitch1) ; //获取对象可枚举的属性，以数组形式返回
										//数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。
		Object.freeze(object) // 方法可以冻结一个对象。冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。
								//也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。
		Object.isFreeze(object) // 判断对象是否冰封

		bitch1.log(bitch1.name); 
		bitch1.log(allProperty); 
		bitch1.log(keys);

		var ni = new String();
		console.log(ni.hasOwnProperty('length')); //新建的string对象拥有自己的length属性
		console.log(ni.hasOwnProperty('substring')); //新建的string不拥有substring属性
		console.log(String.prototype.hasOwnProperty('substring')); //string原型拥有substring属性

		var input = document.createElement('input');//用js创建一个dom对象
		console.log('type' in input);
		console.log(input.hasOwnProperty('placeholder'));

		Object.defineProperties//有时间再msdn上看一看，主要是用于对象属性的更改 
		//getOwnPropertyNames,keys是ECMAScript5新增

		判断对象是否拥有一个属性
		两种方法： object.hasOwnProperty(proName) 或者 proName in object //proName为字符串
		如果含有该属性，返回true，否则返回false

		//设置一个不可被更改的属性
	--------------------------------------------------------------------------
	
	数组Array

	直接在末端添加元素,并返回素组更新后的长度 array.push()
	直接在首端添加元素,并返回素组更新后的长度 array.unshift()
	array[index] = bula

	array.slice(start,end) 返回一个子数组end【可选,如果没有则一直到结尾处】，不包含【end】
	array.splice(index,howmany,item1,item2・・・・) 从index开始删除元素，howmany表示要删除多少个元素【可为0】，item表示插入再index位置的元素

	array.join('分隔符')	把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
	array.concat(array1/item1) 连接【数组/具体的值】

	array.reverse() 反转数组

	eg: array = [0,1,2];
		array.splice(1,0,'a','b','c');
		console.log(array);//输出[0,'a','b','c',1,2]
		array[10]=1;
		console.log(array.length);//输出为11，也就是说此时数组被拉长，array[7]=undefined
		array.pop();// pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。
		array.shift();// shift() 方法将删除 arrayObject 的第一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。
		array.join('-----');//如果没有参数，默认逗号分隔元素
		array.toString();//元素间以逗号分隔

		array.sort() //如果没有回调函数，会对数组进行【万国码排序？】
					// eg:[1,0,5,21] 结果[0,1,21,5]
			对数组按大小排序
				array.sort(function(a,b){
					return a-b
				})
			随机排序
				array.sort(function(a,b){
					return Math.random()>.5 ? -1 : 1; 
				})
	ecmascript5
		array.filter(function(element){ //按条件对元素进行过滤，返回一个新数组
			return true/false
		});
		array.map(function(element,index,array){
			//map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。
			//callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身
			return sth ;
		})
		array.forEach(function(element,index,array){
			//forEach() 方法让数组的每一项都执行一次给定的函数。
		})

   --------------------------------------------------------------------------
   max-width\max-height /min-height/min-width 非css3啊，我去你大爷的
   max-width和max-width联合使用

   background-size,background-clip,background-orign属于css新增属性

   块级元素margin问题
   <div id="parent" class="" style="">
		<div id="child" class="" style="margin:50px 0;height:50px;background:pink;width:100%;"></div>
		<div id="child2" class="" style="margin:50px 0;height:50px;background:pink;width:100%;"></div>
		<div id="child3" class="" style="margin:40px 0;height:50px;background:pink;width:100%;"></div>
		<div id="child4" class="" style="margin:150px 0;height:50px;background:pink;width:100%;"></div>
	</div>
	发现【child】的margin-top,margin-bottom冒泡到【parent】，但是console.log一下parent的margin-top为0px//解决方法是为父级元素添加【padding:1px/border:1px】可解决，但是对于没有padding/border的父级元素呢、可以通过float或者position:absolute解决
	【child】和【child2】间的margin不是50+50=100 ,依然是50px


	在这个说明中，“collapsing margins”（折叠margin）的意思是：2个或以上盒模型之间（关系可以是相邻或嵌套）相邻的margin属性（这之间不能有非空内容、padding区域、border边框
	或使用清除分离方法）结合表示为一个单独的margin。
	在css2.1中，水平的margin不会被折叠。
	垂直margin可能在一些盒模型中被折叠：
	1、在常规文档流中，2个或以上的块级盒模型相邻的垂直margin会被折叠。
	最终的margin值计算方法如下：
	a、全部都为正值，取最大者；
	b、不全是正值，则都取绝对值，然后用正值减去最大值；
	c、没有正值，则都取绝对值，然后用0减去最大值。
	注意：相邻的盒模型可能由DOM元素动态产生并没有相邻或继承关系。
	2、相邻的盒模型中，如果其中的一个是浮动的（floated），垂直margin不会被折叠，甚至一个浮动的盒模型和它的子元素之间也是这样。
	3、设置了overflow属性的元素和它的子元素之间的margin不会被折叠（overflow取值为visible除外）。
	4、设置了绝对定位（position:absolute）的盒模型，垂直margin不会被折叠，甚至和他们的子元素之间也是一样。
	5、设置了display:inline-block的元素，垂直margin不会被折叠，甚至和他们的子元素之间也是一样。
	6、如果一个盒模型的上下margin相邻，这时它的margin可能折叠覆盖（collapse through）它。在这种情况下，元素的位置（position）取决于它的相邻元素的margin是否被折叠。
	a、如果元素的margin和它的父元素的margin-top折叠在一起，盒模型border-top的边界定义和它的父元素相同。
	b、另外，任意元素的父元素不参与margin的折叠，或者说只有父元素的margin-bottom是参与计算的。如果元素的border-top非零，那么元素的border-top边界位置和原来一样。
	一个应用了清除操作的元素的margin-top绝不会和它的块级父元素的margin-bottom折叠。
	注意，那些已经被折叠覆盖的元素的位置对其他已经被折叠的元素的位置没有任何影响；只有在对这些元素的子元素定位时，border-top边界位置才是必需的。
	7、根元素的垂直margin不会被折叠。
	浮动的块级元素的margin-bottom总是与它后面的浮动块级兄弟元素（floated next in-flow block-level sibling）的margin-top相邻，除非那个同级元素使用了清除操作。
	浮动的块级元素的margin-top和它的第一个浮动块级子元素（floated first in-flow block-level child）的margin-top相邻（如果该元素没有border-top，没有padding-top，并且子元素没有使用清除操作）。
	浮动的块级元素的margin-bottom如果符合下列条件，那么它和它的最后一个浮动块级子元素的margin-bottom相邻（如果该元素没有指定padding-bottom或border）：
	a、指定了height:auto
	b、min-height小于元素的实际使用高度（height）
	c、max-height大于元素的实际使用高度（height）
	如果一个元素的min-height属性设置为0，那么它所拥有的margin是相邻的，并且它既没有border-top和border- bottom，也没有padding-top和padding-bottom，它的height属性可以是0或auto，它不能包含一个内联的盒模型 （line box），它所有的浮动子元素（如果有的话）的margin也都是相邻的。
	当一个元素拥有的margin折叠了，并且它使用了清除操作，那么它的margin-top会和紧随其后的兄弟元素的相邻margin折叠，但结果是它的margin将无法和其块级父元素的margin-bottom折叠。
	折叠操作是以padding、margin、border的值为基础的（即在浏览器解析所有这些值之后），折叠后的margin计算将覆盖已使用的不同margin的值。

	-------------------------------------------------------------------------------------------------------------------------
	避免被双击选中元素
	对于ie和chrome、Safari添加属性 onselectstart="return false;" 
	对于Firefox添加样式 style="-moz-user-select:none;"

	----------------------------------------------------------
	在做手机端开发时候，渐渐对像素级的差别变得敏感、
	手机端默认字体大小是16px，那么假设我们设置了一个12px的字体，那他的line-height依然是16px
	这实在令人恶心，故而当设置了元素的字体后，最好跟上他的line-height，以防万一
	font-size:12px;line-height:12px;
    要注意【line-height】的继承问题
	------------------------------------------------------------------
	关于手机端的滑动问题
	event.stopPropagation()阻止冒泡
	event.preventDefault() 阻止默认事件【在滑动方面主要是浏览器提供的默认事件，比如返回上一页等】
	具体安排是这样的
	id.addEventListener('touchstart',function(event){
		event.stopPropagation();
		event.targetTouches[0].screenX //获取X坐标
		event.targetTouches[0].screenY //获取Y坐标
	});
	id.addEventListener('touchmove',function(event){
		event.stopPropagation();
		event.preventDefault();
	});
	id.addEventListener('touchstart',function(event){
		event.stopPropagation();
	});

	----------------------------------------------------
	关于cookie存储中文的问题
	经过测试cookie经过js内部提供的对象【escape等】编码中文，存储，在获取，解码，还是乱码。
	在【segmentfault】上看到要使用【Base64】来编解码。//这是为什么呢？

	cookie编码续
	经过测试【base64】也会出现问题，主要是因为对于【字母，数字】的解码问题，有时候会在后面跟上一个【补全字符】 //故而，有时间还是要研究一下编码方式的【阮一峰有关于这方面的博客】

	最后的解决方是: 不对要存储的字符串进行编码处理，而是直接存储，提取的时候进行【unescape】解码，就可以得到正常的字符串了  //对中英文混输也有效
	难道这不是因为默认对字符串进行了escape处理吗？

	---------------------------------------------------------------------------

	ajax请求
	ajax 请求可分为【get/post】两类
	post对传递数据大小没有限制，而get有
	post默认使用utf-8编码，而get不是,因此如果有传递中文的需要可使用post【也可以加上 contentType:'application/x-www-form-urlencoded; charset=UTF-8'】//【application/x-www-form-urlencoded】是什么意思呢
	关于跨域请求需要使用jsonp【dateType:jsonp】
	post不支持跨域请求，get支持。【在chrome上测试发现post跨域请求会被转成get请求】

	使用post跨域请求
	现代浏览器将其转换成get请求，而又因为get请求默认的不是utf-8编码，故而此时如果传递中文，在服务器端接受到的将是乱码
	因此需要加上【contentType:'application/x-www-form-urlencoded; charset=UTF-8'】

	或者直接 【encodeURI(str)】//对可能含有中文字符的字符串进行编码，以方面后台解码

-------------------------------------------------------------------------------------------------
	滑动问题
	以前总是以为，如果一个div可以左右滑动，那么他的上下滑动就不能使用浏览器的默认事件了
	今日发下错矣。
	var xx,yy,XX,YY,swipeX,swipeY;
	div.addEventListener('touchstart',function(event){
		xx = event.targetTouches[0].screenX;
		yy = event.targetTouches[0].screenY;
		XX = xx ;
		YY = yy ;
		swipeX = true ;
		swipeY = true ;
	});
	div.addEventListener('touchmove',function(event){
		XX = event.targetTouches[0].screenX;
		YY = event.targetTouches[0].screenY;
		if(swipeX && Math.abs(XX-xx)-Math.abs(YY-yy)>0){
			swipeY = false ;
			event.stopPropagation();
			event.preventDefault();
		}
		if(swipeY && Math.abs(XX-xx)-Math.abs(YY-yy)<0){
			swipeX = false ;
		}
	})

	-----------------------------------------------------------------------------------
	在dom不没加载完的时候，使用可以往【代码所处script区下面写，且不会清空dom】
	document.write()
	<script type="text/javascript">
		document.write('<script type="text/javascript" src="js/jquery.10.0.min.js"></script>');
	</script>
	/*  执行结果类似这样
		<script type="text/javascript">
			document.write('<script type="text/javascript" src="js/jquery.10.0.min.js"></script>');
		</script>
		<script type="text/javascript" src="js/jquery.10.0.min.js"></script>
	*/
	反则会清空dom，
	因此在jquery的

	$(function(){
		//这里不可使用document.write(),否则会情况dom
	})

	--------------------------------------------------------------------------------------------------------------------
	移动端如何点击input弹出数字输入界面
	可以用type="tel"来实现
	<input type="tel" placeholder="输入手机号"/> 

	关于input的一些介绍
	上传图片
	<input type="file" accept="image/*"/> 

	文件和其他数据同时异步上传，要用到html5新特性 FormData
	设置每个需要上传数据的input的name
	<form id="info">
		<input type="file" name="file1" accept="image/*"/> 
		<input type="file" name="file2" accept="image/*"/> 
		<input type="password" name="password"/> 
		<input type="tel" name="username"/> 
		<div contentEidtable="true" id="message"></div>
	</form>

	var formdata = new FormData(document.getElementById('info'));//此初始化可以把所有带有name属性的input所包含的信息带上
	//如果想同时上传【message的text()】，要用到formdata的【append】方法
	var message = $('#message').text();
	//添加
	formdata.append('message',message);//如果存在，在value后新增一个value，不存在就新增一个
	//删除可以用delete方法
	formdata.delete('message');
	//查询是否已经含有
	formdata.has('message');//返回一个boolean值
	//设置
	formdata.set('message','12333');//如果key存在，就复写value，如果不存在就新增一个
	//获取
	formdata.get('message');//或取第一个value值
	formdata.getAll('message');//以数组形式返回此key对应的所有value值
		
	原生处理方法---------------------------------------------------------------------------------------

	var xhr = new XMLHttpRequest();
　　xhr.open('POST', $(this).attr('action'));
　　　　// 定义上传完成后的回调函数
　　xhr.onload = function () {
　　　　if (xhr.status === 200) {
　　　　　　console.log('上传成功');
　　　　} else {
　　　　　　　console.log('出错了');
　　　　}
　　};
　　xhr.send(formdata);

	jquery处理方法	-----------------------------------------------------------------------------------------

	$.ajax({
	  url: "http://192.168.16.13:8080/master/api/merchant/register.op",
	  type: "POST",
	  data: formdata,
	  processData: false,  // 告诉jQuery不要去处理发送的数据
	  contentType: false ,  // 告诉jQuery不要去设置Content-Type请求头
	  success:function(data){
		location.href="register-next.html?"+data.merchantId;
	  }
	});
----------------------------------------------------------------------------------------------------------
	JSON.parse(jsonstr); //可以将json字符串转换成json对象 
	JSON.stringify(jsonobj); //可以将json对象转换成json对符串 

	$.parseJSON( jsonstr ); //jQuery.parseJSON(jsonstr),可以将json字符串转换成json对象 

---------------------------------------------------------------------------------------------------------------------
	【localStorage】html5新提供的新特性
	浏览器支持IE8

	localStorage.setItem('bitch','周恩来');//存储一个
	console.log(localStorage.getItem('virgn'))//如果该key不存在，则返回null
	localStorage.removeItem('bitch'); //takes a single argument ― the key of the data item you want to remove ― and removes it from the storage object for that domain.
	localStorage.clear();//清楚所有数据
	console.log(localStorage)//输出为object

	也可以通过 localStorage.key 或者localStorage[key]的形式【赋值/获取】
	如果要想使用localStorage存储图片的话，需要对文件进行编码【base64】

	Responding to storage changes with the StorageEvent
	The StorageEvent is fired whenever a change is made to the Storage object. 
	This won't work on the same page that is making the changes ― it is really a way for other pages on the domain using the storage to sync any changes that are made. 
	Pages on other domains can't access the same storage objects.
	大致意思是可以监听localStorage的key-value变化，但所产生的变化不会发生在本页面上，但在其他页面上可以发生。

	window.addEventListener('storage', function(e) {  
	  document.querySelector('.my-key').textContent = e.key;
	  document.querySelector('.my-old').textContent = e.oldValue;
	  document.querySelector('.my-new').textContent = e.newValue;
	  document.querySelector('.my-url').textContent = e.url;
	  document.querySelector('.my-storage').textContent = e.storageArea;
	});

-------------------------------------------------------------------------------------------------------------------
	select
	获取select标签内部的option 这里有详细介绍 【http://www.w3school.com.cn/jsref/dom_obj_select.asp】
	$(select).find('option:selected')//获取选中的option
	在移动端定义select的位置宽高会有一些bug，值不准确
	解决方法是：在select外部包裹一个div，定义div的宽高位置，然后让select的css{width:100%;height:100%;}
	如果定义div的width:auto;或导致当option的宽度比select的默认宽度宽的时候，出现select宽被撑开的现象，因此需要定义div的宽度

---------------------------------------------------------------------------------------------------------------
	Ajax非异步加载数据
	var paren = function(){
		$.ajax({
			sccess:function(){
				child();
			}
		})
	}
	var child = function(){
		$.ajax({
			sccess:function(){
				console.log(t2 = new Date().getTime());
			}
		})
	}
	
	parent();
	console.log(t1 = new Date().getTime());
	//-----------------------------------结果显示t2>t1
	这说明js并非按行执行

	如果说在parent();执行后，要调用child的加载到的数据，就需要使用callback
	直接 
	parent(); 
	doSth(); //这样是不行的，因为js会在执行child

	var bitch = function(callback){
		if (callback) //先判断参数是否进来
		{
			callback();
		}
		console.log(typeof(callback))
	}
	bitch(function(){
		console.log('我进来了')
	})

------------------------------------------------------------------------------------------------------------------
	.99 表示0.99
	number>>2 表示将其二进制数据右移两位
	number>>2 表示将其二进制数据左移两位

------------------------------------------------------------------------------------------------------------------------
	css3
	-webkit-filter:blur(5px) 对于任何元素都可以 IE不支持

-----------------------------------------------------------------------------------------------------------------------
	var bitch = window.open(url,name,'width=500,height=500');
	bitch.document.getElementById('id').dosth ;//父窗口，访问子窗口
	window.opener.document.getElementById('id').dosth ;//子窗口，访问父窗口

----------------------------------------------------------------------------------------------
	
	js原型模式的执行流程：

	1.先查找构造函数实例里的属性或方法，如果有，就立即返回。
	2.如果构造函数的实例没有，就去它的原型对象里找，如果有，就立即返回

	第一题

	var fun = function(){
		this.name = 'peter';
		return {
		name: 'jack'
		};
	}

	var p = new fun();
	//请问p.name是： jack
	第二题

	var fun = function(){
		this.name = 'peter';

		return 'jack';    
		}

	var p = new fun();
	//请问p.name是： peter
	第三题

	var fun = function(){}

	fun.prototype = {
		info : {
		name : 'peter',
		age : 25
		}
	}

	var a = new fun();
	var b = new fun();

	a.info.name = 'jack';
	b.info.name = 'tom';

	//请问a.info.name和b.info.name分别是：tom,tom
	第四题

	var fun = function(){
		this.info = {
		name : 'peter',
		age : 25
		}
	}

	var a = new fun();
	var b = new fun();

	a.info.name = 'jack';
	b.info.name = 'tom';
	//请问a.info.name和b.info.name分别是：jack tom
	第五题

	var fun = function(){}

	fun.prototype = {    
		name : 'peter',    
		age : 25    
	}

	var a = new fun();
	var b = new fun();

	a.name = 'jack';
	b.name = 'tom';
	//请问a.name和b.name分别是： jack tom
	第六题

	var fun = function(){
		this.info = {
		name : 'peter',
		age : 25
		}
	}

	fun.prototype = {
		info : {
		name : 'peter',
		age : 25
		}
	}

	var a = new fun();
	var b = new fun();

	a.info.name = 'jack';
	b.info.name = 'tom';
	//请问a.info.name和b.info.name分别是： jack tom

	----------------------------------------------------------------------------------------
	segmentfalut 上看到的一个问题
	var array = [1,2,3];
	function clear(arr){
		arr = []
	}
	console.log(array) // 结果为[1,2,3]
	//为什么array的值没有变化呢？
	//在JS中，除了undefined、null、boolean、string、number这五种原始数据类型，其他的都是对象数据类型，也就是说，array、function、date等等这些其实本质上都是JS对象。
    //使用等号（=）将 a 数组赋值到 ary ，等于是 ary 对数组 a 的引用，同理再将 ary = []，改变的是 ary 的引用，不是改变 a 数组本身。
	更进一步来说
	//array = [1,2,3]
	array是对内存中[1,2,3]的地址引用，类似于指针
	在function clear(arr){}中
	形参arr和变量array一样,都是类指针，一开始也指向[1,2,3]
	arr=[];//arr指向一个空数组，并没有对[1,2,3]进行任何操作
	arr.length = 0 ;//arr操作了被引用的数组，而array也引用了这个数组，因此array也会改变

	----------------------------------------------------------------------------------------------------------
	多列
	column
	column-count	规定元素应该被分隔的列数。	
	column-fill	规定如何填充列。	
	column-gap	规定列之间的间隔。	
	column-rule	设置所有 column-rule-* 属性的简写属性。	
	column-rule-color	规定列之间规则的颜色。	
	column-rule-style	规定列之间规则的样式。	
	column-rule-width	规定列之间规则的宽度。	
	column-span	规定元素应该横跨的列数。	
	column-width	规定列的宽度。	
	columns	规定设置 column-width 和 column-count 的简写属性。

	--------------------------------------------------------------------------------
	栅栏结构
	父元素 { display:flex ; display:-webkit-flex ; display: -ms-flex ; display:-moz-flex ; }
	子元素 { flex:auto; flex:20%; flex:1; flex:1em; flex:100px; }

	--------------------------------------------------------------------------
	伪类
	伪类:nth-clild(an+b)匹配在文档树中前面有an+b-1个兄弟元素的元素，此时n大于或等于0，并且该元素具有父元素。简而言之，该选择器匹配多个位置满足an+b的子元素。第一个子元素的位置为1
	:nth-child(3) 表示第三个元素
	:nth-child(odd) 所有奇元素 1,3,5
	:nth-child(2n+1) 所有奇元素 1,3,5
	:nth-child(even) 所有偶元素 2,4,6
	:nth-child(2n) 所有偶元素 2,4,6

	---------------------------------------------------------------------------------
	this 指针，指向当前运行环境
	如果在javascript语言里没有通过new（包括对象字面量定义）、call和apply改变函数的this指针，函数的this指针都是指向window的。
	一个例子
		var name = "蒋中正"
		var obj = {
			name:'abc',
			method:{
				log:function(){
					this.name = '111'
					console.log(this.name);
				},
				name:'周恩来'
			}
		}
		obj.method.log(); //周恩来 在method对象中调用log方法，this指向method，其实this就是method的克隆
		var song = obj.method.log; 
		song(); //蒋中正 在window中运行log方法，this指向window
		var bitch = new obj.method.log(); //uindefined 直接新建了一个log方法，无运行环境？

	call,apply 改变函数的this指针
		其作用一样，只是参数形式有所区别
		call(obj,arguments[0],arguments[1],arguments[2])
		apply(obj,[arguments[0],arguments[1],arguments[2]])

		function a(xx) {
			this.b = xx;
		}
		var o = {};
		a.apply(o, [5]); //首先将a的指针this指向【0】，执行方法a(),a的参数xx=5，也就是为o添加了一个property【b=5】
		alert(b);    // undefined 因此并没有给a的property【b】赋值 
		alert(o.b);    // 5
		a('你大爷');
		console.log(b) //全局对象window下的变量 b='你大爷' ; 等同于 console.log(window.b)

	 "use strict" //使用严格模式
	 在正常模式下，js 函数里那些你没有声明就使用的变量，其实是访问的全局对象的属性，
	 比如说上面正常函数调用的时候，函数里的 this ，就访问的是全局对象。
	 但是在严格模式下，不允许这种语法，所有变量都必须要显示声明，
	 所以如果你不用 call() 传递 this 给这个函数，那么就会报错了。

	 --------------------------------------------------------------------------------------------------------
	 作用域：
	 (function() {
		console.log(a); // undefined 这是因为【变量，函数的定义】会先提升到运行环境的顶部 因此不会显示 a is not defined [a没有被定义]
		console.log(haha()); // '我笑诸葛亮少智，周公瑾无谋' ; a is undefined ;c is not defined ; 由此可见变量要先于function 不然a应该显示a is not defined?
		var a = b = 5;
		function haha(){
			console.log('我笑诸葛亮少智，周公瑾无谋');
			console.log(a)
			console.log(c)
		}
	  })();//写法等同于一下
		 
	 console.log(b); // b=5 
		/*
			var a = b = 5;  //等同于,
			var a ;
			b = 5 ;
			a = b ;
		*/
	 console.log(a); // a is not defined 因为a是一个局部变量

	 (function() {
		var a ;
		function haha(){
			console.log('我笑诸葛亮少智，周公瑾无谋')
		}
		console.log(a); 
		console.log(haha()); 
		a = b = 5;
	  })();
	 
	 严格模式下的写法
	 (function() {
		var a = window.b = 5;
	  })();

	语言定义的命名：比如 this 或者 arguments，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 this 之类的，这样是没有意义的
	形式参数：函数定义时声明的形式参数会作为变量被 hoisting 至该函数的作用域内。所以形式参数是本地的，不是外部的或者全局的。当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了
	函数声明：函数体内部还可以声明函数，不过它们也都是本地的了
	变量声明：这个优先级其实还是最低的，不过它们也都是最常用的

		var x =1000;
		function a(x,y){
			y = function(){ x = 2};
			(function(){
				var x =3;
				y();
				console.log(x); // 3
			}).apply(this) // this指向环境a
			this.x = 50
			console.log(x) // 2
		}
		a();
		console.log(x) //50

	-----------------------------------------------------------------------------------------
	html5 history

	history.forward();
	history.back();
	history.go();
	history.pushState(null,'',url); //添加一个
	history.replaceStateState(null,'',url); //替换当前
	window.onpopstate = function(event){ // 点击浏览器【返回、下一页】时触发
		//根据已改变的url，做一些事情
	}
